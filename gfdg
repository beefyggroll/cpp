import sys
import re
import math
from typing import List, Tuple
import numpy as np
from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
                             QRadioButton, QLineEdit, QPushButton, QLabel, QTextEdit,
                             QFileDialog, QMessageBox, QGroupBox, QSlider)
from PyQt5.QtCore import Qt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
import matplotlib.ticker as ticker


class PlotCanvas(FigureCanvas):
    def __init__(self, parent=None, width=5, height=4, dpi=100):
        self.fig = Figure(figsize=(width, height), dpi=dpi)
        super().__init__(self.fig)
        self.setParent(parent)

        self.axes = self.fig.add_subplot(111)
        self._setup_axes()
        self.initial_xlim = (-10, 10)
        self.initial_ylim = (-10, 10)
        self.axes.set_xlim(self.initial_xlim)
        self.axes.set_ylim(self.initial_ylim)
        self._update_ticks()

        self.current_function = ""
        self.is_analytical = True
        self.tabular_data = None

    def _setup_axes(self):
        self.axes.grid(True, linestyle='--', alpha=0.7)
        self.axes.axhline(y=0, color='k', linewidth=1)
        self.axes.axvline(x=0, color='k', linewidth=1)
        self.axes.set_xlabel('X')
        self.axes.set_ylabel('Y')
        self.axes.set_aspect('auto')

    def _update_ticks(self):
        xlim = self.axes.get_xlim()
        ylim = self.axes.get_ylim()
        x_range = xlim[1] - xlim[0]
        y_range = ylim[1] - ylim[0]

        def round_step(value):
            if value <= 0:
                return 1.0
            log_val = math.floor(math.log10(value))
            mantissa = value / (10 ** log_val)
            if mantissa <= 1:
                return 1 * (10 ** log_val)
            elif mantissa <= 2:
                return 2 * (10 ** log_val)
            elif mantissa <= 5:
                return 5 * (10 ** log_val)
            else:
                return 10 * (10 ** log_val)

        x_step = round_step(x_range / 8) if x_range > 0 else 1.0
        y_step = round_step(y_range / 8) if y_range > 0 else 1.0

        self.axes.xaxis.set_major_locator(ticker.MultipleLocator(x_step))
        self.axes.yaxis.set_major_locator(ticker.MultipleLocator(y_step))
        self.axes.xaxis.set_major_formatter(ticker.FormatStrFormatter('%.6g'))
        self.axes.yaxis.set_major_formatter(ticker.FormatStrFormatter('%.6g'))

    def get_view_params(self):
        xlim = self.axes.get_xlim()
        ylim = self.axes.get_ylim()
        center_x = (xlim[0] + xlim[1]) / 2
        center_y = (ylim[0] + ylim[1]) / 2
        scale = (xlim[1] - xlim[0]) / 20.0
        return center_x, center_y, scale

    def set_view(self, offset_x, offset_y, scale):
        # Ограничиваем масштаб от 0.001 до 1000
        min_scale = 0.001
        max_scale = 1000.0
        scale = max(min_scale, min(max_scale, scale))

        width = 20.0 * scale
        height = width

        left = offset_x - width / 2
        right = offset_x + width / 2
        bottom = offset_y - height / 2
        top = offset_y + height / 2

        self.axes.set_xlim(left, right)
        self.axes.set_ylim(bottom, top)
        self._update_ticks()
        self.draw()

    def plot_analytical_function(self, function_str: str):
        try:
            # Сохраняем текущий вид для восстановления после построения
            current_xlim = self.axes.get_xlim()
            current_ylim = self.axes.get_ylim()

            self.axes.clear()
            self._setup_axes()
            # Устанавливаем временно большой диапазон для корректного обновления тиков
            self.axes.set_xlim(-10000, 10000)
            self.axes.set_ylim(-10000, 10000)
            self._update_ticks()

            expr = function_str.strip()
            expr = re.sub(r'\bln\s*\(', 'log(', expr)
            expr = expr.replace('^', '**')

            def real_cbrt(z):
                return np.sign(z) * np.abs(z) ** (1/3)

            expr = re.sub(
                r'(\([^)]*\)|[a-zA-Z_]\w*|\d+(?:\.\d+)?(?:[eE][+-]?\d+)?|x)\s*\*\*\s*\(?\s*1\s*/\s*3\s*\)?',
                r'real_cbrt(\1)',
                expr
            )

            # === ГЛОБАЛЬНЫЙ ДИАПАЗОН ===
            X_MIN_GLOBAL = -10000
            X_MAX_GLOBAL = 10000
            N_POINTS_GLOBAL = 200000  # 200 тыс. точек — компромисс между скоростью и детализацией

            x_full = np.linspace(X_MIN_GLOBAL, X_MAX_GLOBAL, N_POINTS_GLOBAL)

            local_dict = {
                'x': x_full,
                'np': np,
                'sin': np.sin,
                'cos': np.cos,
                'tan': np.tan,
                'exp': np.exp,
                'log': np.log,
                'log10': np.log10,
                'sqrt': np.sqrt,
                'abs': np.abs,
                'pi': np.pi,
                'e': np.e,
                'cbrt': np.cbrt,
                'real_cbrt': real_cbrt
            }

            import warnings
            with warnings.catch_warnings():
                warnings.simplefilter("ignore")
                y_full = eval(expr, {"__builtins__": {}}, local_dict)

            y_full = np.array(y_full, dtype=np.float64)

            # === Маска разрывов ===
            nan_mask = np.isnan(y_full) | np.isinf(y_full)
            nan_mask |= np.abs(y_full) > 1e4  # отсекаем слишком большие значения

            # Резкие скачки
            if len(y_full) > 1:
                dy = np.abs(np.diff(y_full))
                jump_threshold = 1000.0
                huge_jumps = np.concatenate([dy > jump_threshold, [False]])
                nan_mask |= huge_jumps

            y_clean = y_full.copy()
            y_clean[nan_mask] = np.nan

            # === Разделение на сегменты ===
            segments = []
            current_x, current_y = [], []

            for i in range(len(x_full)):
                if np.isnan(y_clean[i]):
                    if len(current_x) >= 2:
                        segments.append((np.array(current_x), np.array(current_y)))
                    current_x, current_y = [], []
                else:
                    current_x.append(x_full[i])
                    current_y.append(y_clean[i])

            if len(current_x) >= 2:
                segments.append((np.array(current_x), np.array(current_y)))

            # === Рисуем все сегменты ===
            for seg_x, seg_y in segments:
                self.axes.plot(seg_x, seg_y, 'r-', linewidth=1, zorder=1)

            self.axes.set_title(f'График функции: {function_str}')
            self.current_function = function_str
            self.is_analytical = True

            # Восстанавливаем предыдущий вид (масштаб и позицию)
            self.axes.set_xlim(current_xlim)
            self.axes.set_ylim(current_ylim)
            self._update_ticks()
            self.draw()

        except Exception as e:
            raise ValueError(f"Ошибка построения: {str(e)}")

    def reset_view(self):
        self.axes.clear()
        self._setup_axes()
        self.axes.set_xlim(self.initial_xlim)
        self.axes.set_ylim(self.initial_ylim)
        self._update_ticks()
        self.axes.set_title('График функции')
        self.draw()


class FunctionPlotter(QMainWindow):
    def __init__(self):
        super().__init__()
        self.tabular_points = []
        self.init_ui()

    def init_ui(self):
        self.setWindowTitle('Лабораторная работа №1')
        self.setGeometry(100, 100, 1200, 700)

        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QHBoxLayout(central_widget)

        control_panel = QWidget()
        control_panel.setFixedWidth(320)
        control_layout = QVBoxLayout(control_panel)

        type_group = QGroupBox("Тип функции:")
        type_layout = QVBoxLayout(type_group)
        self.radio_analytical = QRadioButton("Аналитическая функция")
        self.radio_tabular = QRadioButton("Табличная функция")
        self.radio_analytical.setChecked(True)
        type_layout.addWidget(self.radio_analytical)
        type_layout.addWidget(self.radio_tabular)

        function_group = QGroupBox("Формула:")
        function_layout = QVBoxLayout(function_group)
        self.txt_function = QLineEdit("(x-1.3)*sqrt(x+1.5)+tan(pi*x/4)")
        self.txt_function.setPlaceholderText("Например: x^(1/3), 1/x, ln(x), tan(x)")
        function_layout.addWidget(QLabel("Функция:"))
        function_layout.addWidget(self.txt_function)

        self.btn_plot = QPushButton("Построить график")
        self.btn_plot.setStyleSheet("background-color: #4682B4; color: white;")
        self.btn_load_file = QPushButton("Загрузить файл")
        self.btn_load_file.setStyleSheet("background-color: #32CD32; color: white;")
        self.btn_load_file.setEnabled(False)
        self.btn_reset = QPushButton("Сброс")
        self.btn_reset.setStyleSheet("background-color: #FFA500; color: white;")

        scale_group = QGroupBox("Масштаб:")
        scale_layout = QVBoxLayout(scale_group)
        self.slider_scale = QSlider(Qt.Horizontal)
        self.slider_scale.setRange(-3000, 3000)  # от -3 до +3 в экспоненте
        self.slider_scale.setValue(0)            # 10^0 = 1
        self.slider_scale.valueChanged.connect(self.on_scale_changed)
        self.label_scale = QLabel("Масштаб: 1.000")
        scale_layout.addWidget(self.label_scale)
        scale_layout.addWidget(self.slider_scale)

        pan_group = QGroupBox("Перемещение:")
        pan_layout = QVBoxLayout(pan_group)
        self.slider_pan_x = QSlider(Qt.Horizontal)
        self.slider_pan_x.setRange(-50000, 50000)
        self.slider_pan_x.setValue(0)
        self.slider_pan_x.valueChanged.connect(self.on_pan_x_changed)
        self.slider_pan_y = QSlider(Qt.Horizontal)
        self.slider_pan_y.setRange(-50000, 50000)
        self.slider_pan_y.setValue(0)
        self.slider_pan_y.valueChanged.connect(self.on_pan_y_changed)
        pan_layout.addWidget(QLabel("По X:"))
        pan_layout.addWidget(self.slider_pan_x)
        pan_layout.addWidget(QLabel("По Y:"))
        pan_layout.addWidget(self.slider_pan_y)

        self.txt_file_content = QTextEdit()
        self.txt_file_content.setReadOnly(True)
        self.txt_file_content.setMaximumHeight(150)
        self.txt_file_content.setVisible(False)

        control_layout.addWidget(type_group)
        control_layout.addWidget(function_group)
        control_layout.addWidget(self.btn_plot)
        control_layout.addWidget(self.btn_load_file)
        control_layout.addWidget(self.btn_reset)
        control_layout.addWidget(scale_group)
        control_layout.addWidget(pan_group)
        control_layout.addWidget(QLabel("Содержимое файла:"))
        control_layout.addWidget(self.txt_file_content)
        control_layout.addStretch()

        self.plot_canvas = PlotCanvas(self, width=8, height=6)
        main_layout.addWidget(control_panel)
        main_layout.addWidget(self.plot_canvas)

        self.radio_analytical.toggled.connect(self.on_function_type_changed)
        self.btn_plot.clicked.connect(self.on_plot_clicked)
        self.btn_load_file.clicked.connect(self.on_load_file_clicked)
        self.btn_reset.clicked.connect(self.on_reset_clicked)

    def on_function_type_changed(self):
        is_analytical = self.radio_analytical.isChecked()
        self.txt_function.setEnabled(is_analytical)
        self.btn_load_file.setEnabled(not is_analytical)
        self.txt_file_content.setVisible(not is_analytical)

    def on_plot_clicked(self):
        try:
            if self.radio_analytical.isChecked():
                self.plot_canvas.plot_analytical_function(self.txt_function.text())
            else:
                if not self.tabular_points:
                    raise ValueError("Сначала загрузите файл")
                self.plot_canvas.plot_tabular_function(self.tabular_points)
        except Exception as e:
            QMessageBox.critical(self, "Ошибка", str(e))

    def on_load_file_clicked(self):
        try:
            path, _ = QFileDialog.getOpenFileName(self, "Открыть TXT файл", "", "Text files (*.txt)")
            if path:
                self.load_tabular_data(path)
        except Exception as e:
            QMessageBox.critical(self, "Ошибка", str(e))

    def on_reset_clicked(self):
        self.plot_canvas.reset_view()
        self.slider_pan_x.setValue(0)
        self.slider_pan_y.setValue(0)
        self.slider_scale.setValue(0)
        self.label_scale.setText("Масштаб: 1.000")

    def on_scale_changed(self, value):
        exponent = value / 1000.0
        scale = 10 ** exponent
        self.label_scale.setText(f"Масштаб: {scale:.3g}")
        cx, cy, _ = self.plot_canvas.get_view_params()
        self.plot_canvas.set_view(cx, cy, scale)

    def on_pan_x_changed(self, value):
        offset_x = value / 1000.0
        _, cy, scale = self.plot_canvas.get_view_params()
        self.plot_canvas.set_view(offset_x, cy, scale)

    def on_pan_y_changed(self, value):
        offset_y = value / 1000.0
        cx, _, scale = self.plot_canvas.get_view_params()
        self.plot_canvas.set_view(cx, offset_y, scale)

    def load_tabular_data(self, file_path: str):
        self.tabular_points = []
        lines_out = []
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if not line or line.startswith(('#', '//')):
                        continue
                    parts = re.split(r'[\s,;]+', line)
                    nums = []
                    for p in parts:
                        p = p.strip().replace(',', '.')
                        if p:
                            try:
                                nums.append(float(p))
                            except:
                                pass
                    if len(nums) >= 2:
                        self.tabular_points.append((nums[0], nums[1]))
                        lines_out.append(f"{nums[0]:.6f} {nums[1]:.6f}")
            if not self.tabular_points:
                raise ValueError("Нет валидных данных")
            self.txt_file_content.setText('\n'.join(lines_out))
        except Exception as e:
            raise ValueError(f"Ошибка файла: {e}")


def main():
    app = QApplication(sys.argv)
    app.setStyle('Fusion')
    window = FunctionPlotter()
    window.show()
    sys.exit(app.exec_())


if __name__ == '__main__':
    main()
#(x-1.3)*sqrt(x+1.5)+tan(pi*x/4)
